<!DOCTYPE html>
<html lang="af">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DILEMMA – Kriptiek</title>

  <!-- Favicon and Meta -->
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon" />
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
  <link rel="manifest" href="/assets/site.webmanifest">
  <meta property="og:title" content="KRIPTIEK" />
  <meta property="og:description" content="Tuiste van DILEMMA en ander Afrikaanse woordraaisels" />
  <meta property="og:url" content="https://www.kriptiek.com/" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta property="og:image" content="https://www.kriptiek.com/assets/WAshare-logo.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Tailwind + font -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: 'Montserrat', sans-serif; background-color: #f9fafb; color: #1f2937; }
    header { background-color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,.1); padding: 1rem; text-align: center; }
    .logo-container { display:flex; justify-content:center; align-items:center; margin-bottom:10px; }
    .logo-container .letter-box { width:40px; height:40px; margin:2px; display:flex; justify-content:center; align-items:center; background-color:#374151; color:#fff; font-size:1.5rem; font-weight:700; border-radius:4px; }

    .game-container { max-width: 640px; margin: 0 auto; padding: 1rem; }
    .tile-row{ display:flex; justify-content:center; margin-bottom:5px; }
    .letter-tile{ width:50px; height:50px; display:flex; justify-content:center; align-items:center; border:2px solid #374151; font-size:1.5rem; font-weight:bold; text-transform:uppercase; margin:2px; background:#fff; color:#1f2937; transition:transform .3s ease; }
    .letter-tile.flip{ animation: flipAnim .5s ease forwards; }
    @keyframes flipAnim{ 0%{transform:rotateX(0)} 50%{transform:rotateX(90deg)} 100%{transform:rotateX(0)} }
    .correct{ background:#16a34a!important; color:#fff!important; }
    .present{ background:#facc15!important; color:#000!important; }
    .absent{ background:#9ca3af!important; color:#fff!important; }

    .keyboard-row{ display:flex; justify-content:center; margin:5px 0; }
    .key{ min-width:30px; padding:10px 12px; margin:2px; border-radius:4px; background:#374151; color:#fff; font-weight:700; cursor:pointer; text-transform:uppercase; }
    .key.bg-green-600{ background:#16a34a!important; }
    .key.bg-red-600{ background:#1e3a8a!important; }

    /* Result modal */
    #resultModal{ display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); align-items:center; justify-content:center; z-index:1000; }
    #resultModal .modal-content{ background:#fff; padding:1.5rem; border-radius:8px; text-align:center; max-width:300px; width:100%; }
    #resultModal button{ margin:5px; padding:8px 16px; border-radius:4px; font-weight:700; }
    .btn-share{ background:#1e3a8a; color:#fff; }
    .btn-close{ background:#6b7280; color:#fff; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

<header>
  <div class="logo-container">
    <div class="letter-box">D</div><div class="letter-box">I</div><div class="letter-box">L</div>
    <div class="letter-box">E</div><div class="letter-box">M</div><div class="letter-box">M</div>
    <div class="letter-box">A</div>
  </div>
  <p class="text-sm text-gray-500">Welkom terug, <span id="playerName" class="font-semibold text-green-700"></span>!</p>
</header>

<main class="flex-grow game-container">
  <div id="clue" class="text-center text-lg mb-4 text-gray-700 font-semibold">Laai die leidraad...</div>
  <div id="game-grid" class="mb-6"></div>
  <div id="keyboard" class="mb-2"></div>

  <!-- NEW: status line (success/fail summary) -->
  <p id="statusLine" class="text-center font-bold text-[#1e3a8a] mb-4" style="display:none;"></p>

  <!-- GESELS SAAM button lives here -->
  <div class="mb-6 flex justify-center">
    <a href="/forum.html" id="chatButton"
       class="inline-block bg-[#1e3a8a] hover:bg-[#1b3170] text-white text-sm font-bold px-4 py-2 rounded">
      GESELS SAAM
    </a>
  </div>

  <!-- HOE OM TE SPEEL -->
  <div class="mt-2 bg-white rounded shadow p-4">
    <h2 class="text-xl font-bold mb-2">HOE OM DILEMMA TE SPEEL</h2>
    <p class="text-gray-700 leading-relaxed mb-2">
      Jy het ses kanse om die woord te raai.<br>
      Jy mag vir elke probeerslag enige letters in enige volgorde kies, maar elke raaiskoot moet dieselfde aantal letters hê as die woord waarna jy soek. Dit hoef nie ook 'n woord te vorm nie.<br>
      Gebruik jou toetsbord of die een op die skerm om jou raaiskoot in te tik, dan ENTER.
    </p>
    <p class="text-gray-700 italic mb-2">
      WENK: Op kleiner skerms kan jy Dilemma soos 'n foto met jou vingers kleiner trek totdat dit heeltemal inpas.
    </p>
    <p class="text-gray-700 leading-relaxed">
      <span class="font-bold text-green-700">GROEN</span>: Die letter is in die antwoord en in die regte blokkie.<br>
      <span class="font-bold text-yellow-600">GEEL</span>: Die letter is in die antwoord, maar nie in die regte blokkie nie.<br>
      <span class="font-bold text-gray-500">GRYS</span>: Die letter is glad nie in die antwoord nie.
    </p>
    <h3 class="text-lg font-bold mt-4">JOU STATISTIEK</h3>
    <ul class="list-disc pl-6 text-gray-700 space-y-1">
      <li><strong>Een poging per raaisel:</strong> Sodra jy klaar gespeel het (wen of verloor), word daardie raaisel vir jou gesluit.</li>
      <li><strong>Ouer raaisels is oop:</strong> Jy kan enige vroeëre Dilemma steeds aanpak as jy dit nog nie gedoen het nie.</li>
      <li><strong>Alles tel vir jou statistiek:</strong> Elke voltooide raaisel word ingereken by jou <strong>sukseskoers</strong> (% opgelos), dit wil sê al die Dilemmas wat jy kon oplos as 'n persentasie van die totale aantal wat jy al gespeel het.</li>
      <li><strong>Wenlopie:</strong> Dit is jou lopie van suksesvolle opeenvolgende Dilemmas gespeel, in enige volgorde waarin jy kies om hulle te speel (dus nie noodwendig chronologies nie).</li>
      <li><strong>Leierbord:</strong> Omdat jy elke raaisel <em>net een keer</em> mag speel, kan jou naam nie meer as een keer op daardie dag se leierbord verskyn nie.</li>
    </ul>
    <p class="text-sm text-gray-500 mt-2">
      Let wel: Jou vordering is aan hierdie blaaier en toestel gekoppel, maar sal ook beskikbaar wees as jy elders met dieselfde besonderhede aanmeld.
    </p>
  </div>

  <!-- LEADERBOARD -->
  <div id="leaderboard" class="mt-6 bg-white rounded shadow p-4">
    <div class="flex items-center justify-between mb-2">
      <h2 class="text-xl font-bold">Vandag se bestes:</h2>
    </div>
    <ul id="leaderboardList" class="text-gray-700 text-left"><li>Laai...</li></ul>
  </div>
</main>

<footer class="bg-white shadow p-4 text-center text-sm text-gray-500">
  &copy; 2025 Kriptiek. Alle regte voorbehou. |
  <a href="/index.html" class="underline">Tuis</a> |
  <a href="/profile.html" class="underline">My profiel</a> |
  <a href="/forum.html" class="underline">Gesels saam</a> |
  <a href="/privacy.html" class="underline">Privaatheidsbeleid</a> |
  <a href="/terms.html" class="underline">Voorwaardes</a> |
  <a href="/faq.html" class="underline">Gereelde vrae</a> |
  <a href="/about.html" class="underline">Oor Kriptiek</a> |
  <a href="/contact.html" class="underline">Kontak ons</a>
</footer>

<!-- RESULT MODAL -->
<div id="resultModal">
  <div class="modal-content">
    <p id="resultMessage" class="mb-4 font-bold"></p>
    <button id="modalShareBtn" class="btn-share">DEEL</button>
    <button id="closeModalBtn" class="btn-close">SLUIT</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, collection, collectionGroup, setDoc, getDocs, serverTimestamp
} from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyDH-nVvGkdaheH7pvRHH0M9TbW2f98lMGQ",
  authDomain: "kriptiek-c9ea2.firebaseapp.com",
  projectId: "kriptiek-c9ea2",
  storageBucket: "kriptiek-c9ea2.appspot.com",
  messagingSenderId: "620450620939",
  appId: "1:620450620939:web:e93a18ac23b53b33db890e"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// ---------- UI refs ----------
const gameGrid = document.getElementById("game-grid");
const keyboard = document.getElementById("keyboard");
const modal = document.getElementById("resultModal");
const resultMsg = document.getElementById("resultMessage");
const shareBtn = document.getElementById("modalShareBtn");
const closeBtn = document.getElementById("closeModalBtn");
const leaderboardList = document.getElementById("leaderboardList");
const playerNameEl = document.getElementById("playerName");
const statusLine = document.getElementById("statusLine");

// ---------- State ----------
let gridRows = 6, gridCols = 5;
let currentRow = 0, currentCol = 0;
let board = [], targetWord = "", gameOver = false;

let currentUid = null;
let displayName = localStorage.getItem("userName") || "Speler";

const params = new URLSearchParams(window.location.search);

// ZA-safe default
function todayZA() {
  const now = new Date();
  const p = new Intl.DateTimeFormat('af-ZA', {
    timeZone: 'Africa/Johannesburg',
    year: 'numeric', month: '2-digit', day: '2-digit'
  }).formatToParts(now).reduce((a, x) => (a[x.type] = x.value, a), {});
  return `${p.year}-${p.month}-${p.day}`;
}

const gameId = params.get("gameId") || `Game${todayZA()}`;
const doneKey = `dilemma-${gameId}-done`;
const progressKey = `dilemma-${gameId}-progress`;
const gameUrl = window.location.href;

// Old/new ID mapper
function altIdIfOldFormat(id) {
  const m = id.match(/^Game(\d{4}-\d{2}-\d{2})$/);
  return m ? m[1] : null;
}

playerNameEl.textContent = displayName;

// ---------- Helpers ----------
function disableGame() {
  gameOver = true;
  document.querySelectorAll(".key").forEach(key => key.disabled = true);
}

async function serverLockExists() {
  if (!currentUid) return false;
  try {
    const p = await getDoc(doc(db, "userGames", currentUid, "plays", gameId));
    if (p.exists()) return true;
    const alt = altIdIfOldFormat(gameId);
    if (alt) {
      const p2 = await getDoc(doc(db, "userGames", currentUid, "plays", alt));
      if (p2.exists()) return true;
    }
  } catch {}
  return false;
}

async function getPlaySummary() {
  if (!currentUid) return null;
  try {
    let snap = await getDoc(doc(db, "userGames", currentUid, "plays", gameId));
    if (!snap.exists()) {
      const alt = altIdIfOldFormat(gameId);
      if (alt) snap = await getDoc(doc(db, "userGames", currentUid, "plays", alt));
    }
    if (!snap.exists()) return null;
    const d = snap.data() || {};
    return { didWin: d.result === "win", guesses: Number(d.guesses) || null };
  } catch { return null; }
}

async function recordPlay(guessCount, didWin) {
  if (!currentUid) return;
  try {
    await setDoc(
      doc(db, "userGames", currentUid, "plays", gameId),
      {
        finished: true,
        result: didWin ? "win" : "loss",
        guesses: Math.trunc(Number(guessCount)),
        finishedAt: serverTimestamp(),
      },
      { merge: true }
    );
  } catch (e) {
    console.warn("Could not store play-lock:", e);
  }
}

// Backfill your own leaderboard row if missing
async function ensureLeaderboardRowOnLoad() {
  if (!currentUid) return;
  try {
    const lbRef = doc(db, "games", gameId, "leaderboard", currentUid);
    const lbSnap = await getDoc(lbRef);
    if (lbSnap.exists()) return;

    let playSnap = await getDoc(doc(db, "userGames", currentUid, "plays", gameId));
    if (!playSnap.exists()) {
      const alt = altIdIfOldFormat(gameId);
      if (alt) playSnap = await getDoc(doc(db, "userGames", currentUid, "plays", alt));
    }
    if (!playSnap.exists()) return;

    const play = playSnap.data() || {};
    const guesses = Math.trunc(Number(play.guesses)) || gridRows;

    // Name & success rate (best effort)
    let name = displayName;
    let successRate = null;
    try {
      const uDoc = await getDoc(doc(db, "users", currentUid));
      if (uDoc.exists()) {
        const u = uDoc.data() || {};
        if (typeof u.userName === "string" && u.userName.trim()) name = u.userName.trim();
        const gp = Number(u.gamesPlayed || 0), w = Number(u.wins || 0);
        successRate = gp > 0 ? Math.round((w / gp) * 100) : 0;
      }
    } catch {}

    await setDoc(lbRef, {
      userName: name,
      guesses,
      successRate,
      date: serverTimestamp(),
      createdAtMs: Date.now()
    }, { merge: true });
  } catch (e) {
    console.warn("ensureLeaderboardRowOnLoad:", e);
  }
}

// ---------- Load game data ----------
async function loadGameData() {
  const gameRef = doc(db, "games", gameId);
  const snap = await getDoc(gameRef);
  if (snap.exists()) {
    const data = snap.data();
    targetWord = (data.word || "").toUpperCase();
    gridCols = targetWord.length || 5;
    document.getElementById("clue").textContent = data.clue || "Geen leidraad beskikbaar nie.";
  } else {
    targetWord = "WATER";
    gridCols = targetWord.length;
    document.getElementById("clue").textContent = "Geen leidraad beskikbaar nie.";
  }
}

function createGrid() {
  gameGrid.innerHTML = "";
  board = [];
  for (let r = 0; r < gridRows; r++) {
    const row = document.createElement("div");
    row.className = "tile-row";
    const rowTiles = [];
    for (let c = 0; c < gridCols; c++) {
      const tile = document.createElement("div");
      tile.className = "letter-tile";
      row.appendChild(tile);
      rowTiles.push(tile);
    }
    board.push(rowTiles);
    gameGrid.appendChild(row);
  }
}

function createKeyboard() {
  keyboard.innerHTML = "";
  const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
  layout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.className = "keyboard-row";
    [...row].forEach(letter => {
      const key = document.createElement("button");
      key.className = "key";
      key.textContent = letter;
      key.onclick = () => handleKey(letter);
      rowDiv.appendChild(key);
    });
    if (row === "ZXCVBNM") {
      const enter = document.createElement("button");
      enter.className = "key bg-green-600";
      enter.textContent = "Enter";
      enter.onclick = handleEnter;
      rowDiv.appendChild(enter);

      const back = document.createElement("button");
      back.className = "key bg-red-600";
      back.textContent = "←";
      back.onclick = handleBackspace;
      rowDiv.appendChild(back);
    }
    keyboard.appendChild(rowDiv);
  });
}

function updateKeyboard(letter, state) {
  const keyBtn = [...document.querySelectorAll(".key")].find(k => k.textContent === letter);
  if (!keyBtn) return;
  if (state === "correct" || (state === "present" && !keyBtn.classList.contains("correct"))) {
    keyBtn.classList.remove("present", "absent");
    keyBtn.classList.add(state);
  } else if (state === "absent" && !keyBtn.classList.contains("correct") && !keyBtn.classList.contains("present")) {
    keyBtn.classList.add("absent");
  }
}

function handleKey(letter) {
  if (gameOver) return;
  if (currentCol < gridCols && currentRow < gridRows) {
    board[currentRow][currentCol].textContent = letter;
    currentCol++;
  }
}

function handleBackspace() {
  if (gameOver || currentCol === 0) return;
  currentCol--;
  board[currentRow][currentCol].textContent = "";
}

function handleEnter() {
  if (gameOver) return;
  if (currentCol < gridCols) return alert("Vul al die letters in!");
  const guess = board[currentRow].map(t => t.textContent).join("");
  checkGuessWithFlip(guess);
}

function computeStates(guess) {
  const states = new Array(gridCols).fill("absent");
  const letterCounts = {};
  for (let ch of targetWord) letterCounts[ch] = (letterCounts[ch] || 0) + 1;

  for (let i = 0; i < gridCols; i++) {
    if (guess[i] === targetWord[i]) {
      states[i] = "correct";
      letterCounts[guess[i]]--;
    }
  }
  for (let i = 0; i < gridCols; i++) {
    if (states[i] === "correct") continue;
    if (letterCounts[guess[i]] > 0) {
      states[i] = "present";
      letterCounts[guess[i]]--;
    }
  }
  return states;
}

function applyStatesWithFlip(rowIndex, guess, states) {
  states.forEach((s, i) => {
    const tile = board[rowIndex][i];
    setTimeout(() => {
      tile.classList.remove("correct","present","absent");
      tile.classList.add("flip", s);
      updateKeyboard(guess[i], s);
    }, i * 350);
  });
}

// ---- Save/restore progress ----
function saveLocalProgress(done=false) {
  const rows = [];
  for (let r = 0; r < gridRows; r++) {
    const guess = board[r].map(t => t.textContent).join("");
    if (!guess.trim()) break;
    const states = board[r].map(t =>
      t.classList.contains("correct") ? "correct" :
      t.classList.contains("present") ? "present" : "absent"
    );
    if (states.every(s=>["correct","present","absent"].includes(s))) {
      rows.push({ guess, states });
    } else {
      break;
    }
  }
  localStorage.setItem(progressKey, JSON.stringify({ rows }));
  if (done) localStorage.setItem(doneKey, "true");
}

function restoreLocalProgress() {
  const saved = localStorage.getItem(progressKey);
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    if (!data?.rows) return;
    data.rows.forEach(({ guess, states }) => {
      const letters = guess.split("");
      for (let i = 0; i < letters.length; i++) {
        const tile = board[currentRow][i];
        tile.textContent = letters[i];
        tile.classList.remove("correct","present","absent");
        tile.classList.add(states[i], "flip");
        updateKeyboard(letters[i], states[i]);
      }
      currentRow++;
      currentCol = 0;
    });
  } catch {}
}

// ---------- Leaderboard ----------
async function submitScore(guessCount, didWin) {
  if (!currentUid) {
    console.warn("No auth; skipping leaderboard write.");
    return;
  }

  // Resolve display name from /users if possible
  try {
    const uDoc = await getDoc(doc(db, "users", currentUid));
    if (uDoc.exists() && typeof uDoc.data().userName === "string") {
      displayName = uDoc.data().userName || displayName;
      playerNameEl.textContent = displayName;
      localStorage.setItem("userName", displayName);
    }
  } catch (e) {
    console.warn("Could not read users doc:", e);
  }

  let successRate = null;

  // Try to update /users stats (but do NOT block leaderboard on failure)
  try {
    const uref = doc(db, "users", currentUid);
    const before = await getDoc(uref);

    let payload;
    if (before.exists()) {
      const u = before.data() || {};
      const newGames  = (u.gamesPlayed || 0) + 1;
      const newWins   = (u.wins || 0) + (didWin ? 1 : 0);
      const newStreak = didWin ? (u.streak || 0) + 1 : 0;
      const newBest   = Math.max(u.bestStreak || 0, newStreak);
      const dist = { "1":0,"2":0,"3":0,"4":0,"5":0,"6":0, ...(u.guessDist || {}) };
      if (didWin && guessCount >= 1 && guessCount <= 6) {
        dist[String(guessCount)] = (dist[String(guessCount)] || 0) + 1;
      }
      payload = {
        userName: displayName,
        gamesPlayed: newGames,
        wins: newWins,
        streak: newStreak,
        bestStreak: newBest,
        guessDist: dist,
        updatedAt: serverTimestamp()
      };
    } else {
      payload = {
        userName: displayName,
        gamesPlayed: 1,
        wins: didWin ? 1 : 0,
        streak: didWin ? 1 : 0,
        bestStreak: didWin ? 1 : 0,
        guessDist: { "1":0,"2":0,"3":0,"4":0,"5":0,"6":0, ...(didWin && guessCount>=1 && guessCount<=6 ? { [String(guessCount)]: 1 } : {}) },
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };
    }
    await setDoc(uref, payload, { merge: true });

    const after = await getDoc(uref);
    const nd = after.data() || {};
    const games = Number(nd.gamesPlayed || 0);
    const wins  = Number(nd.wins || 0);
    successRate = games > 0 ? Math.round((wins / games) * 100) : 0;
  } catch (e) {
    console.warn("User stats update failed (non-fatal):", e);
  }

  // ALWAYS write/merge the leaderboard row
  try {
    await setDoc(
      doc(db, "games", gameId, "leaderboard", currentUid),
      {
        userName: displayName,
        guesses: Math.trunc(Number(guessCount)),
        successRate: (successRate === null ? undefined : successRate),
        date: serverTimestamp(),
        createdAtMs: Date.now()
      },
      { merge: true }
    );
  } catch (e) {
    console.error("Kon nie leierbord-ry stoor nie:", e);
  }
}

// Leaderboard (primary: subcollection; fallback: collectionGroup('plays') if allowed)
async function loadLeaderboard() {
  try {
    // 1) Try the game's own leaderboard subcollection first
    const snap = await getDocs(collection(db, "games", gameId, "leaderboard"));
    let entries = [];
    let needSR = [];

    snap.forEach(d => {
      const v = d.data() || {};
      const guessesNum = Number(v.guesses);
      if (!Number.isFinite(guessesNum) || guessesNum < 1 || guessesNum > gridRows) return;

      const name = (typeof v.userName === "string" && v.userName.trim()) ? v.userName.trim() : "Onbekend";
      const ts = v.date?.seconds ? v.date.seconds * 1000 :
                 (typeof v.createdAtMs === "number" ? v.createdAtMs : 0);
      const sr = Number.isFinite(Number(v.successRate)) ? Math.trunc(Number(v.successRate)) : null;

      entries.push({ uid: d.id, name, guesses: guessesNum, when: ts, sr });
      if (sr == null) needSR.push(d.id);
    });

    if (needSR.length) {
      const userDocs = await Promise.all(needSR.map(uid => getDoc(doc(db, "users", uid))));
      userDocs.forEach((uDoc, i) => {
        if (!uDoc.exists()) return;
        const u = uDoc.data() || {};
        const gp = Number(u.gamesPlayed || 0);
        const w  = Number(u.wins || 0);
        const sr = gp > 0 ? Math.round((w / gp) * 100) : 0;
        const ent = entries.find(e => e.uid === needSR[i]);
        if (ent && ent.sr == null) ent.sr = sr;
      });
    }

    // 2) If nothing there yet, FALL BACK from plays (if rules allow)
    if (!entries.length) {
      try {
        const cg = await getDocs(collectionGroup(db, "plays"));
        const fb = [];
        cg.forEach(p => {
          if (p.id !== gameId) return;
          const v = p.data() || {};
          const guesses = Math.trunc(Number(v.guesses));
          if (!Number.isFinite(guesses) || guesses < 1 || guesses > gridRows) return;
          const when = v.finishedAt?.seconds ? v.finishedAt.seconds * 1000 : 0;
          const uid = p.ref.parent.parent.id;
          fb.push({ uid, guesses, when });
        });

        if (fb.length) {
          const docs = await Promise.all(fb.map(r => getDoc(doc(db, "users", r.uid))));
          fb.forEach((r, i) => {
            const u = docs[i].exists() ? (docs[i].data() || {}) : {};
            r.name = (typeof u.userName === "string" && u.userName.trim()) ? u.userName.trim() : "Onbekend";
            const gp = Number(u.gamesPlayed || 0), w = Number(u.wins || 0);
            r.sr = gp > 0 ? Math.round((w / gp) * 100) : 0;
          });
          entries = fb;
        }
      } catch (e) {
        console.warn("Fallback leaderboard from plays failed:", e);
      }
    }

    // 3) Render
    leaderboardList.innerHTML = "";
    if (!entries.length) {
      leaderboardList.innerHTML =
        `<li class="bg-green-100 font-medium px-2 py-1 rounded">Jy kan eerste op die leierbord wees!</li>`;
      return;
    }

    entries.sort((a, b) => (a.guesses - b.guesses) || (a.when - b.when));
    entries.forEach((e, idx) => {
      const li = document.createElement("li");
      if (idx === 0) li.className = "font-bold bg-green-100";
      const woord = e.guesses === 1 ? 'raaiskoot' : 'raaiskote';
      li.innerHTML =
        `<strong>${e.name}</strong>: ${e.guesses} ${woord}` +
        (Number.isFinite(e.sr) ? ` · ${e.sr}%-sukseskoers` : "");
      leaderboardList.appendChild(li);
    });
  } catch (err) {
    console.error("Kon nie leierbord laai nie:", err);
    leaderboardList.innerHTML = `<li class="text-red-600">Kon nie leierbord laai nie.</li>`;
  }
}

// ---------- Game end flows ----------
async function gameCompleted(guessCount) {
  gameOver = true;
  const woord = guessCount === 1 ? 'raaiskoot' : 'raaiskote';

  statusLine.textContent = `Jy het hierdie Dilemma in ${guessCount} ${woord} opgelos`;
  statusLine.style.display = "block";

  resultMsg.textContent = `Veels geluk, ${displayName}, jy het die woord in ${guessCount} ${woord} gekry!`;
  modal.style.display = "flex";
  shareBtn.onclick = () => navigator.clipboard.writeText(`Ek het DILEMMA in ${guessCount} ${woord} opgelos: ${gameUrl}`);

  saveLocalProgress(true);
  await recordPlay(guessCount, true);
  await submitScore(guessCount, true);
  await ensureLeaderboardRowOnLoad();
  await loadLeaderboard();
  document.querySelectorAll(".key").forEach(k => k.disabled = true);
}

async function gameFailed() {
  gameOver = true;

  statusLine.textContent = `Jy kon nie hierdie Dilemma oplos nie`;
  statusLine.style.display = "block";

  resultMsg.textContent = `Jammer, ${displayName}! Vandag se oplossing is ${targetWord}.`;
  modal.style.display = "flex";
  shareBtn.onclick = () =>
    navigator.clipboard.writeText(`Ek kon nie hierdie DILEMMA oplos nie. Probeer self by ${gameUrl}`);

  saveLocalProgress(true);
  await recordPlay(gridRows, false);
  await submitScore(gridRows, false);
  await ensureLeaderboardRowOnLoad();
  await loadLeaderboard();
  document.querySelectorAll(".key").forEach(k => k.disabled = true);
}

closeBtn.onclick = () => { modal.style.display = "none"; };

document.addEventListener("keydown", e => {
  if (e.key === "Enter") handleEnter();
  else if (e.key === "Backspace") handleBackspace();
  else if (/^[a-zA-Z]$/.test(e.key)) handleKey(e.key.toUpperCase());
});

function checkGuessWithFlip(guess) {
  const states = computeStates(guess);
  applyStatesWithFlip(currentRow, guess, states);

  setTimeout(async () => {
    saveLocalProgress(false);
    if (guess === targetWord) {
      await gameCompleted(currentRow + 1);
    } else {
      currentRow++;
      currentCol = 0;
      if (currentRow >= gridRows) {
        await gameFailed();
      } else {
        saveLocalProgress(false);
      }
    }
  }, gridCols * 350 + 20);
}

// ---------- Init sequence ----------
onAuthStateChanged(auth, async (user) => {
  currentUid = user?.uid || null;

  if (currentUid) {
    try {
      const uDoc = await getDoc(doc(db, "users", currentUid));
      const nm = uDoc.exists() ? uDoc.data()?.userName : null;
      if (typeof nm === "string" && nm.trim()) {
        displayName = nm.trim();
        localStorage.setItem("userName", displayName);
      }
    } catch {}
  }
  playerNameEl.textContent = displayName;

  await loadGameData();
  createGrid();
  createKeyboard();
  restoreLocalProgress();

  // If previously completed, disable and show summary
  const lsDone = localStorage.getItem(doneKey) === "true";
  const fsDone = await serverLockExists();
  if (lsDone || fsDone) {
    const s = await getPlaySummary();
    if (s) {
      statusLine.textContent = s.didWin
        ? `Jy het hierdie Dilemma in ${s.guesses} ${s.guesses === 1 ? 'raaiskoot' : 'raaiskote'} opgelos`
        : `Jy kon nie hierdie Dilemma oplos nie`;
      statusLine.style.display = "block";
    }
    disableGame();
  } else {
    const someWin = board.some(row => row.length && row.every(t => t.classList.contains("correct")));
    const reachedMax = currentRow >= gridRows && !someWin;
    if (someWin || reachedMax) {
      statusLine.textContent = someWin
        ? `Jy het hierdie Dilemma opgelos`
        : `Jy kon nie hierdie Dilemma oplos nie`;
      statusLine.style.display = "block";
      disableGame();
    }
  }

  // Extra fallback: old local key on this device
  if (!lsDone && !fsDone) {
    const alt = altIdIfOldFormat(gameId);
    if (alt && localStorage.getItem(`dilemma-${alt}-done`) === 'true') {
      statusLine.textContent = `Jy het hierdie Dilemma opgelos`;
      statusLine.style.display = "block";
      disableGame();
    }
  }

  await ensureLeaderboardRowOnLoad();
  await loadLeaderboard();
});
</script>
</body>
</html>
