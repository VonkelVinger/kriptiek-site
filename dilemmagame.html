<!DOCTYPE html>
<html lang="af">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DILEMMA – Kriptiek</title>

  <!-- Favicon and Meta -->
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon" />
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
  <link rel="manifest" href="/assets/site.webmanifest">
  <meta property="og:title" content="KRIPTIEK" />
  <meta property="og:description" content="Tuiste van DILEMMA en ander Afrikaanse woordraaisels" />
  <meta property="og:url" content="https://www.kriptiek.com/" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta property="og:image" content="https://www.kriptiek.com/assets/WAshare-logo.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />

  <!-- Tailwind + font -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: 'Montserrat', sans-serif; background-color: #f9fafb; color: #1f2937; }
    header { background-color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,.1); padding: 1rem; text-align: center; }
    .logo-container { display:flex; justify-content:center; align-items:center; margin-bottom:10px; }
    .logo-container .letter-box { width:40px; height:40px; margin:2px; display:flex; justify-content:center; align-items:center; background-color:#374151; color:#fff; font-size:1.5rem; font-weight:700; border-radius:4px; }

    .game-container { max-width: 640px; margin: 0 auto; padding: 1rem; }
    .tile-row{ display:flex; justify-content:center; margin-bottom:5px; }
    .letter-tile{ width:50px; height:50px; display:flex; justify-content:center; align-items:center; border:2px solid #374151; font-size:1.5rem; font-weight:bold; text-transform:uppercase; margin:2px; background:#fff; color:#1f2937; transition:transform .3s ease; }
    .letter-tile.flip{ animation: flipAnim .5s ease forwards; }
    @keyframes flipAnim{ 0%{transform:rotateX(0)} 50%{transform:rotateX(90deg)} 100%{transform:rotateX(0)} }
    .correct{ background:#16a34a!important; color:#fff!important; }
    .present{ background:#facc15!important; color:#000!important; }
    .absent{ background:#9ca3af!important; color:#fff!important; }

    .keyboard-row{ display:flex; justify-content:center; margin:5px 0; }
    .key{ min-width:30px; padding:10px 12px; margin:2px; border-radius:4px; background:#374151; color:#fff; font-weight:700; cursor:pointer; text-transform:uppercase; }
    .key.bg-green-600{ background:#16a34a!important; }
    .key.bg-red-600{ background:#1e3a8a!important; }

    #lockoutMessage{ display:none; text-align:center; margin-top:10px; font-weight:700; color:#1e3a8a; font-size:1.1rem; opacity:0; animation: fadeIn 1s forwards; }
    #lockoutMessage .icon{ margin-right:6px; }
    @keyframes fadeIn{ from{opacity:0; transform:translateY(-5px)} to{opacity:1; transform:translateY(0)} }

    #leaderboard{ border:1px solid #e5e7eb; }
    #leaderboardList li{ padding:6px 8px; transition: background-color .2s ease; }
    #leaderboardList li:nth-child(odd){ background:#f9fafb; }
    #leaderboardList li:nth-child(even){ background:#fff; }
    #leaderboardList li:hover{ background:#e0e7ff; }

    #resultModal{ display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); align-items:center; justify-content:center; z-index:1000; }
    #resultModal .modal-content{ background:#fff; padding:1.5rem; border-radius:8px; text-align:center; max-width:300px; width:100%; }
    #resultModal button{ margin:5px; padding:8px 16px; border-radius:4px; font-weight:700; }
    .btn-share{ background:#1e3a8a; color:#fff; }
    .btn-close{ background:#6b7280; color:#fff; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

<header>
  <div class="logo-container">
    <div class="letter-box">D</div><div class="letter-box">I</div><div class="letter-box">L</div>
    <div class="letter-box">E</div><div class="letter-box">M</div><div class="letter-box">M</div>
    <div class="letter-box">A</div>
  </div>
  <p class="text-sm text-gray-500">Welkom terug, <span id="playerName" class="font-semibold text-green-700"></span>!</p>
</header>

<main class="flex-grow game-container">
  <div id="clue" class="text-center text-lg mb-4 text-gray-700 font-semibold">Laai die leidraad...</div>
  <div id="game-grid" class="mb-6"></div>
  <div id="keyboard" class="mb-6"></div>
  <p id="lockoutMessage"><span class="icon">🔒</span>Jy kan môre weer speel</p>

  <!-- HOE OM TE SPEEL ... (unchanged help text) -->
<div class="mt-6 bg-white rounded shadow p-4">
  <h2 class="text-xl font-bold mb-2">HOE OM DILEMMA TE SPEEL</h2>
  <p class="text-gray-700 leading-relaxed mb-2">
    Jy het ses kanse om die woord te raai.<br>
    Jy mag vir elke probeerslag enige letters in enige volgorde kies, maar elke raaiskoot moet dieselfde aantal letters hê as die woord waarna jy soek. Dit hoef nie ook 'n woord te vorm nie.<br>
    Gebruik jou toetsbord of die een op die skerm om jou raaiskoot in te tik, dan ENTER.
  </p>
  <p class="text-gray-700 italic mb-2">
    WENK: Op kleiner skerms kan jy Dilemma soos 'n foto met jou vingers kleiner trek totdat dit heeltemal inpas.
  </p>
  <p class="text-gray-700 leading-relaxed">
    <span class="font-bold text-green-700">GROEN</span>: Die letter is in die antwoord en in die regte blokkie.<br>
    <span class="font-bold text-yellow-600">GEEL</span>: Die letter is in die antwoord, maar nie in die regte blokkie nie.<br>
    <span class="font-bold text-gray-500">GRYS</span>: Die letter is glad nie in die antwoord nie.
  </p>
<h3 class="text-lg font-bold mt-4">JOU STATISTIEK</h3>
<ul class="list-disc pl-6 text-gray-700 space-y-1">
  <li><strong>Een poging per raaisel:</strong> Sodra jy klaar gespeel het (wen of verloor), word daardie raaisel vir jou gesluit.</li>
  <li><strong>Ouer raaisels is oop:</strong> Jy kan enige vroeëre Dilemma steeds aanpak as jy dit nog nie gedoen het nie.</li>
  <li><strong>Alles tel vir jou statistiek:</strong> Elke voltooide raaisel word ingereken by jou <strong>sukseskoers</strong> (% opgelos), dit wil sê al die Dilemmas wat jy kon oplos as 'n persentasie van die totale aantal wat jy al gespeel het.</li>
  <li><strong>Wenlopie:</strong> Dit is jou lopie van suksesvolle opeenvolgende Dilemmas gespeel, in enige volgorde waarin jy kies om hulle te speel (dus nie noodwendig chronologies nie).</li>
  <li><strong>Leierbord:</strong> Omdat jy elke raaisel net <em>een keer</em> mag speel, kan jou naam nie meer as een keer op daardie dag se leierbord verskyn nie.</li>
</ul>
<p class="text-sm text-gray-500 mt-2">
  Let wel: Jou vordering is aan hierdie blaaier en toestel gekoppel, maar sal ook beskikbaar wees as jy elders met dieselfde besonderhede aanmeld.
</p>
</div>
  <!-- LEADERBOARD + GESELS SAAM -->
  <div id="leaderboard" class="mt-6 bg-white rounded shadow p-4">
    <div class="flex items-center justify-between mb-2">
      <h2 class="text-xl font-bold">Vandag se bestes:</h2>
      <a href="/forum.html" class="inline-block bg-[#1e3a8a] hover:bg-[#1b3170] text-white text-sm font-bold px-3 py-2 rounded">GESELS SAAM</a>
    </div>
    <ul id="leaderboardList" class="text-gray-700 text-left"><li>Laai...</li></ul>
  </div>
</main>

<footer class="bg-white shadow p-4 text-center text-sm text-gray-500">
  &copy; 2025 Kriptiek. Alle regte voorbehou. |
  <a href="/index.html" class="underline">Tuis</a>
  <a href="/forum.html" class="underline ml-2">Gesels saam</a>
  <a href="/privacy.html" class="underline ml-2">Privaatheidsbeleid</a> |
  <a href="/terms.html" class="underline">Voorwaardes</a> |
  <a href="/faq.html" class="underline">Gereelde vrae</a> |
  <a href="/about.html" class="underline">Oor Kriptiek</a> |
  <a href="/contact.html" class="underline">Kontak ons</a>
</footer>

<!-- RESULT MODAL -->
<div id="resultModal">
  <div class="modal-content">
    <p id="resultMessage" class="mb-4 font-bold"></p>
    <button id="modalShareBtn" class="btn-share">DEEL</button>
    <button id="closeModalBtn" class="btn-close">SLUIT</button>
  </div>
</div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, collection, setDoc, getDocs, serverTimestamp
} from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
import {
  getAuth, onAuthStateChanged, signInAnonymously
} from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyDH-nVvGkdaheH7pvRHH0M9TbW2f98lMGQ",
  authDomain: "kriptiek-c9ea2.firebaseapp.com",
  projectId: "kriptiek-c9ea2",
  storageBucket: "kriptiek-c9ea2.appspot.com",
  messagingSenderId: "620450620939",
  appId: "1:620450620939:web:e93a18ac23b53b33db890e"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
// Ensure everyone has a UID (so server lock + rules apply)
signInAnonymously(auth).catch(() => {});

// ---------- UI refs ----------
const gameGrid = document.getElementById("game-grid");
const keyboard = document.getElementById("keyboard");
const lockoutMessage = document.getElementById("lockoutMessage");
const modal = document.getElementById("resultModal");
const resultMsg = document.getElementById("resultMessage");
const shareBtn = document.getElementById("modalShareBtn");
const closeBtn = document.getElementById("closeModalBtn");
const leaderboardList = document.getElementById("leaderboardList");
const playerNameEl = document.getElementById("playerName");

// ---------- State ----------
let gridRows = 6, gridCols = 5;
let currentRow = 0, currentCol = 0;
let board = [], targetWord = "", gameOver = false;

// These now come from Auth (with localStorage as a fallback for greeting only)
let currentUid = null;
let displayName = localStorage.getItem("userName") || "Speler";

const params = new URLSearchParams(window.location.search);
const gameId = params.get("gameId") || `Game${new Date().toISOString().split('T')[0]}`;
const doneKey = `dilemma-${gameId}-done`;
const progressKey = `dilemma-${gameId}-progress`;
const gameUrl = window.location.href;

playerNameEl.textContent = displayName;

// ---------- Helpers ----------
function disableGame(message = "Jy het hierdie een reeds vandag gespeel") {
  gameOver = true;
  document.getElementById("clue").textContent = message;
  lockoutMessage.style.display = "block";
  document.querySelectorAll(".key").forEach(key => key.disabled = true);
}

async function serverLockExists() {
  if (!currentUid) return false;
  try {
    const p = await getDoc(doc(db, "userGames", currentUid, "plays", gameId));
    return p.exists();
  } catch {
    return false;
  }
}

async function recordPlay(guessCount, didWin) {
  if (!currentUid) return;
  try {
    await setDoc(
      doc(db, "userGames", currentUid, "plays", gameId),
      {
        finished: true,
        result: didWin ? "win" : "loss",
        guesses: Math.trunc(Number(guessCount)),
        finishedAt: serverTimestamp(),
      },
      { merge: true }
    );
  } catch (e) {
    console.warn("Could not store play-lock:", e);
  }
}

async function loadGameData() {
  const gameRef = doc(db, "games", gameId);
  const snap = await getDoc(gameRef);
  if (snap.exists()) {
    const data = snap.data();
    targetWord = (data.word || "").toUpperCase();
    gridCols = targetWord.length || 5;
    document.getElementById("clue").textContent = data.clue || "Geen leidraad beskikbaar nie.";
  } else {
    targetWord = "WATER";
    gridCols = targetWord.length;
    document.getElementById("clue").textContent = "Geen leidraad beskikbaar nie.";
  }
}

function createGrid() {
  gameGrid.innerHTML = "";
  board = [];
  for (let r = 0; r < gridRows; r++) {
    const row = document.createElement("div");
    row.className = "tile-row";
    const rowTiles = [];
    for (let c = 0; c < gridCols; c++) {
      const tile = document.createElement("div");
      tile.className = "letter-tile";
      row.appendChild(tile);
      rowTiles.push(tile);
    }
    board.push(rowTiles);
    gameGrid.appendChild(row);
  }
}

function createKeyboard() {
  keyboard.innerHTML = "";
  const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
  layout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.className = "keyboard-row";
    [...row].forEach(letter => {
      const key = document.createElement("button");
      key.className = "key";
      key.textContent = letter;
      key.onclick = () => handleKey(letter);
      rowDiv.appendChild(key);
    });
    if (row === "ZXCVBNM") {
      const enter = document.createElement("button");
      enter.className = "key bg-green-600";
      enter.textContent = "Enter";
      enter.onclick = handleEnter;
      rowDiv.appendChild(enter);

      const back = document.createElement("button");
      back.className = "key bg-red-600";
      back.textContent = "←";
      back.onclick = handleBackspace;
      rowDiv.appendChild(back);
    }
    keyboard.appendChild(rowDiv);
  });
}

function updateKeyboard(letter, state) {
  const keyBtn = [...document.querySelectorAll(".key")].find(k => k.textContent === letter);
  if (!keyBtn) return;
  if (state === "correct" || (state === "present" && !keyBtn.classList.contains("correct"))) {
    keyBtn.classList.remove("present", "absent");
    keyBtn.classList.add(state);
  } else if (state === "absent" && !keyBtn.classList.contains("correct") && !keyBtn.classList.contains("present")) {
    keyBtn.classList.add("absent");
  }
}

function handleKey(letter) {
  if (gameOver) return;
  if (currentCol < gridCols && currentRow < gridRows) {
    board[currentRow][currentCol].textContent = letter;
    currentCol++;
  }
}

function handleBackspace() {
  if (gameOver || currentCol === 0) return;
  currentCol--;
  board[currentRow][currentCol].textContent = "";
}

function handleEnter() {
  if (gameOver) return;
  if (currentCol < gridCols) return alert("Vul al die letters in!");
  const guess = board[currentRow].map(t => t.textContent).join("");
  checkGuessWithFlip(guess);
}

function computeStates(guess) {
  const states = new Array(gridCols).fill("absent");
  const letterCounts = {};
  for (let ch of targetWord) letterCounts[ch] = (letterCounts[ch] || 0) + 1;

  for (let i = 0; i < gridCols; i++) {
    if (guess[i] === targetWord[i]) {
      states[i] = "correct";
      letterCounts[guess[i]]--;
    }
  }
  for (let i = 0; i < gridCols; i++) {
    if (states[i] === "correct") continue;
    if (letterCounts[guess[i]] > 0) {
      states[i] = "present";
      letterCounts[guess[i]]--;
    }
  }
  return states;
}

function applyStatesWithFlip(rowIndex, guess, states) {
  states.forEach((s, i) => {
    const tile = board[rowIndex][i];
    setTimeout(() => {
      tile.classList.remove("correct","present","absent");
      tile.classList.add("flip", s);
      updateKeyboard(guess[i], s);
    }, i * 350);
  });
}

// ---- Save/restore progress ----
function saveLocalProgress(done=false) {
  const rows = [];
  for (let r = 0; r < gridRows; r++) {
    const guess = board[r].map(t => t.textContent).join("");
    if (!guess.trim()) break;
    const states = board[r].map(t =>
      t.classList.contains("correct") ? "correct" :
      t.classList.contains("present") ? "present" : "absent"
    );
    if (states.every(s=>["correct","present","absent"].includes(s))) {
      rows.push({ guess, states });
    } else {
      break;
    }
  }
  localStorage.setItem(progressKey, JSON.stringify({ rows }));
  if (done) localStorage.setItem(doneKey, "true");
}

function restoreLocalProgress() {
  const saved = localStorage.getItem(progressKey);
  if (!saved) return;
  try {
    const data = JSON.parse(saved);
    if (!data?.rows) return;
    data.rows.forEach(({ guess, states }) => {
      const letters = guess.split("");
      for (let i = 0; i < letters.length; i++) {
        const tile = board[currentRow][i];
        tile.textContent = letters[i];
        tile.classList.remove("correct","present","absent");
        tile.classList.add(states[i], "flip");
        updateKeyboard(letters[i], states[i]);
      }
      currentRow++;
      currentCol = 0;
    });
  } catch {}
}

// ---------- Leaderboard ----------
async function submitScore(guessCount, didWin) {
  if (!currentUid) {
    console.warn("No auth; skipping leaderboard write.");
    return;
  }

  try {
    // Prefer Firestore-stored name if available
    try {
      const uDoc = await getDoc(doc(db, "users", currentUid));
      if (uDoc.exists() && typeof uDoc.data().userName === "string") {
        displayName = uDoc.data().userName || displayName;
        playerNameEl.textContent = displayName;
        localStorage.setItem("userName", displayName);
      }
    } catch (e) {
      console.warn("Could not read users doc:", e);
    }

    // Update aggregated stats (users/{uid})
    const uref = doc(db, "users", currentUid);
    const before = await getDoc(uref);

    let payload;
    if (before.exists()) {
      const u = before.data() || {};
      const newGames  = (u.gamesPlayed || 0) + 1;
      const newWins   = (u.wins || 0) + (didWin ? 1 : 0);
      const newStreak = didWin ? (u.streak || 0) + 1 : 0;
      const newBest   = Math.max(u.bestStreak || 0, newStreak);
      const dist = { "1":0,"2":0,"3":0,"4":0,"5":0,"6":0, ...(u.guessDist || {}) };
      if (didWin && guessCount >= 1 && guessCount <= 6) {
        dist[String(guessCount)] = (dist[String(guessCount)] || 0) + 1;
      }
      payload = {
        userName: displayName,
        gamesPlayed: newGames,
        wins: newWins,
        streak: newStreak,
        bestStreak: newBest,
        guessDist: dist,
        updatedAt: serverTimestamp()
      };
    } else {
      payload = {
        userName: displayName,
        gamesPlayed: 1,
        wins: didWin ? 1 : 0,
        streak: didWin ? 1 : 0,
        bestStreak: didWin ? 1 : 0,
        guessDist: { "1":0,"2":0,"3":0,"4":0,"5":0,"6":0, ...(didWin && guessCount>=1 && guessCount<=6 ? { [String(guessCount)]: 1 } : {}) },
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };
    }
    await setDoc(uref, payload, { merge: true });

    // Compute success rate and write leaderboard doc (CREATE-only by rules; OK on first play)
    const after = await getDoc(uref);
    const nd = after.data() || {};
    const games = Number(nd.gamesPlayed || 0);
    const wins  = Number(nd.wins || 0);
    const successRate = games > 0 ? Math.round((wins / games) * 100) : 0;

    const lbDocRef = doc(db, "games", gameId, "leaderboard", currentUid);
    const toWrite = {
      userName: displayName,
      guesses: Math.trunc(Number(guessCount)),
      successRate: Math.max(0, Math.min(100, Math.trunc(successRate))),
      date: serverTimestamp(),      // required by rules
      createdAtMs: Date.now()       // for tie-break in UI
    };
    await setDoc(lbDocRef, toWrite, { merge: true }); // second attempt is denied by rules (create-only)
  } catch (e) {
    console.error("Kon nie telling stoor nie:", e);
  }
}

async function loadLeaderboard() {
  try {
    const snap = await getDocs(collection(db, "games", gameId, "leaderboard"));
    const entries = [];
    const needSR = [];

    snap.forEach(d => {
      const v = d.data() || {};
      const guessesNum = Number(v.guesses);
      if (!Number.isFinite(guessesNum) || guessesNum < 1 || guessesNum > gridRows) return;

      const name = (typeof v.userName === "string" && v.userName.trim()) ? v.userName.trim() : "Onbekend";
      const ts = v.date?.seconds ? v.date.seconds * 1000 :
                 (typeof v.createdAtMs === "number" ? v.createdAtMs : 0);
      const sr = Number.isFinite(Number(v.successRate)) ? Math.trunc(Number(v.successRate)) : null;

      entries.push({ uid: d.id, name, guesses: guessesNum, when: ts, sr });
      if (sr == null) needSR.push(d.id);
    });

    // Fallback: compute SR from users/{uid} if missing
    if (needSR.length) {
      const userDocs = await Promise.all(needSR.map(uid => getDoc(doc(db, "users", uid))));
      userDocs.forEach((uDoc, i) => {
        if (!uDoc.exists()) return;
        const u = uDoc.data() || {};
        const gp = Number(u.gamesPlayed || 0);
        const w  = Number(u.wins || 0);
        const sr = gp > 0 ? Math.round((w / gp) * 100) : 0;
        const ent = entries.find(e => e.uid === needSR[i]);
        if (ent && ent.sr == null) ent.sr = sr;
      });
    }

    leaderboardList.innerHTML = "";
    if (!entries.length) {
      leaderboardList.innerHTML =
        `<li class="bg-green-100 font-medium px-2 py-1 rounded">Jy kan eerste op die leierbord wees!</li>`;
      return;
    }

    // Best (fewest guesses) first; ties = earlier write first
    entries.sort((a, b) => (a.guesses - b.guesses) || (a.when - b.when));

    entries.forEach((e, idx) => {
      const li = document.createElement("li");
      if (idx === 0) li.className = "font-bold bg-green-100";
      li.innerHTML =
        `<strong>${e.name}</strong>: ${e.guesses} raaiskote` +
        (Number.isFinite(e.sr) ? ` · ${e.sr}% sukseskoers` : "");
      leaderboardList.appendChild(li);
    });
  } catch (err) {
    console.error("Kon nie leierbord laai nie:", err);
    leaderboardList.innerHTML = `<li class="text-red-600">Kon nie leierbord laai nie.</li>`;
  }
}

// ---------- Game end flows ----------
async function gameCompleted(guessCount) {
  gameOver = true;
  resultMsg.textContent = `Veels geluk, ${displayName}, jy het die woord in ${guessCount} raaiskote gekry!`;
  modal.style.display = "flex";
  shareBtn.onclick = () =>
    navigator.clipboard.writeText(`Ek het DILEMMA in ${guessCount} raaiskote opgelos: ${gameUrl}`);
  lockoutMessage.style.display = "block";

  saveLocalProgress(true);
  await recordPlay(guessCount, true);
  await submitScore(guessCount, true);
  await loadLeaderboard();
  document.querySelectorAll(".key").forEach(k => k.disabled = true);
}

async function gameFailed() {
  gameOver = true;
  resultMsg.textContent = `Jammer, ${displayName}! Vandag se oplossing is ${targetWord}.`;
  modal.style.display = "flex";
  shareBtn.onclick = () =>
    navigator.clipboard.writeText(`Ek kon nie DILEMMA oplos nie. Probeer self: ${gameUrl}`);
  lockoutMessage.style.display = "block";

  saveLocalProgress(true);
  await recordPlay(gridRows, false);
  await submitScore(gridRows, false);
  await loadLeaderboard();
  document.querySelectorAll(".key").forEach(k => k.disabled = true);
}

closeBtn.onclick = () => { modal.style.display = "none"; };

document.addEventListener("keydown", e => {
  if (e.key === "Enter") handleEnter();
  else if (e.key === "Backspace") handleBackspace();
  else if (/^[a-zA-Z]$/.test(e.key)) handleKey(e.key.toUpperCase());
});

function checkGuessWithFlip(guess) {
  const states = computeStates(guess);
  applyStatesWithFlip(currentRow, guess, states);

  setTimeout(async () => {
    saveLocalProgress(false);
    if (guess === targetWord) {
      await gameCompleted(currentRow + 1);
    } else {
      currentRow++;
      currentCol = 0;
      if (currentRow >= gridRows) {
        await gameFailed();
      } else {
        saveLocalProgress(false);
      }
    }
  }, gridCols * 350 + 20);
}

// ---------- Init sequence (wait for Auth so writes are authenticated) ----------
onAuthStateChanged(auth, async (user) => {
  currentUid = user?.uid || null;

  // Prefer Firestore-stored name if signed in
  if (currentUid) {
    try {
      const uDoc = await getDoc(doc(db, "users", currentUid));
      const nm = uDoc.exists() ? uDoc.data()?.userName : null;
      if (typeof nm === "string" && nm.trim()) {
        displayName = nm.trim();
        localStorage.setItem("userName", displayName);
      }
    } catch {}
  }
  playerNameEl.textContent = displayName;

  await loadGameData();
  createGrid();
  createKeyboard();
  restoreLocalProgress();

  // Server-enforced lock (cross-device) + local lock
  const lsDone = localStorage.getItem(doneKey) === "true";
  const fsDone = await serverLockExists();
  if (lsDone || fsDone) {
    disableGame();
  } else {
    const someWin = board.some(row => row.length && row.every(t => t.classList.contains("correct")));
    const reachedMax = currentRow >= gridRows && !someWin;
    if (someWin || reachedMax) disableGame();
  }

  await loadLeaderboard();
});
</script>
</body>
</html>
